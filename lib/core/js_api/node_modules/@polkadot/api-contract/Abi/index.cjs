"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Abi = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _toLatest = require("./toLatest.cjs");

// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
const l = (0, _util.logger)('Abi');
const PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

function findMessage(list, messageOrId) {
  const message = (0, _util.isNumber)(messageOrId) ? list[messageOrId] : (0, _util.isString)(messageOrId) ? list.find(_ref => {
    let {
      identifier
    } = _ref;
    return [identifier, (0, _util.stringCamelCase)(identifier)].includes(messageOrId.toString());
  }) : messageOrId;
  return (0, _util.assertReturn)(message, () => `Attempted to call an invalid contract interface, ${(0, _util.stringify)(messageOrId)}`);
}

function parseJson(json, chainProperties) {
  const registry = new _types.TypeRegistry();
  const info = registry.createType('ContractProjectInfo', json);
  const metadata = registry.createType('ContractMetadata', (0, _util.isString)(json.metadataVersion) ? {
    V0: json
  } : {
    V1: json.V1
  });
  const latest = metadata.isV0 ? (0, _toLatest.toLatest)(registry, metadata.asV0) : metadata.asV1;
  const lookup = registry.createType('PortableRegistry', {
    types: latest.types
  }); // attach the lookup to the registry - now the types are known

  registry.setLookup(lookup);

  if (chainProperties) {
    registry.setChainProperties(chainProperties);
  } // warm-up the actual type, pre-use


  lookup.types.forEach(_ref2 => {
    let {
      id
    } = _ref2;
    return lookup.getTypeDef(id);
  });
  return [json, registry, latest, info];
}

var _createArgs = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("createArgs");

var _createEvent = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("createEvent");

var _createMessage = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("createMessage");

var _decodeArgs = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("decodeArgs");

var _decodeMessage = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("decodeMessage");

var _encodeArgs = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("encodeArgs");

class Abi {
  constructor(abiJson, chainProperties) {
    var _this = this;

    this.events = void 0;
    this.constructors = void 0;
    this.info = void 0;
    this.json = void 0;
    this.messages = void 0;
    this.metadata = void 0;
    this.registry = void 0;
    Object.defineProperty(this, _createArgs, {
      writable: true,
      value: (args, spec) => {
        return args.map((_ref3, index) => {
          let {
            name,
            type
          } = _ref3;

          try {
            (0, _util.assert)((0, _util.isObject)(type), 'Invalid type definition found');
            const displayName = type.displayName.length ? type.displayName[type.displayName.length - 1].toString() : undefined;
            const camelName = (0, _util.stringCamelCase)(name);

            if (displayName && PRIMITIVE_ALWAYS.includes(displayName)) {
              return {
                name: camelName,
                type: {
                  info: _types.TypeDefInfo.Plain,
                  type: displayName
                }
              };
            }

            const typeDef = this.registry.lookup.getTypeDef(type.type);
            return {
              name: camelName,
              type: displayName && !typeDef.type.startsWith(displayName) ? {
                displayName,
                ...typeDef
              } : typeDef
            };
          } catch (error) {
            l.error(`Error expanding argument ${index} in ${(0, _util.stringify)(spec)}`);
            throw error;
          }
        });
      }
    });
    Object.defineProperty(this, _createEvent, {
      writable: true,
      value: (spec, index) => {
        const args = (0, _classPrivateFieldLooseBase2.default)(this, _createArgs)[_createArgs](spec.args, spec);

        const event = {
          args,
          docs: spec.docs.map(d => d.toString()),
          fromU8a: data => ({
            args: (0, _classPrivateFieldLooseBase2.default)(this, _decodeArgs)[_decodeArgs](args, data),
            event
          }),
          identifier: spec.name.toString(),
          index
        };
        return event;
      }
    });
    Object.defineProperty(this, _createMessage, {
      writable: true,
      value: function (spec, index) {
        let add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        const args = (0, _classPrivateFieldLooseBase2.default)(_this, _createArgs)[_createArgs](spec.args, spec);

        const identifier = spec.name.toString();
        const message = { ...add,
          args,
          docs: spec.docs.map(d => d.toString()),
          fromU8a: data => ({
            args: (0, _classPrivateFieldLooseBase2.default)(_this, _decodeArgs)[_decodeArgs](args, data),
            message
          }),
          identifier,
          index,
          method: (0, _util.stringCamelCase)(identifier),
          selector: spec.selector,
          toU8a: params => (0, _classPrivateFieldLooseBase2.default)(_this, _encodeArgs)[_encodeArgs](spec, args, params)
        };
        return message;
      }
    });
    Object.defineProperty(this, _decodeArgs, {
      writable: true,
      value: (args, data) => {
        // for decoding we expect the input to be just the arg data, no selectors
        // no length added (this allows use with events as well)
        let offset = 0;
        return args.map(_ref4 => {
          let {
            type: {
              lookupName,
              type
            }
          } = _ref4;
          const value = this.registry.createType(lookupName || type, data.subarray(offset));
          offset += value.encodedLength;
          return value;
        });
      }
    });
    Object.defineProperty(this, _decodeMessage, {
      writable: true,
      value: (type, list, data) => {
        const [, trimmed] = (0, _util.compactStripLength)(data);
        const selector = trimmed.subarray(0, 4);
        const message = list.find(m => m.selector.eq(selector));
        (0, _util.assert)(message, `Unable to find ${type} with selector ${(0, _util.u8aToHex)(selector)}`);
        return message.fromU8a(trimmed.subarray(4));
      }
    });
    Object.defineProperty(this, _encodeArgs, {
      writable: true,
      value: (_ref5, args, data) => {
        let {
          name,
          selector
        } = _ref5;
        (0, _util.assert)(data.length === args.length, () => `Expected ${args.length} arguments to contract message '${name.toString()}', found ${data.length}`);
        return (0, _util.compactAddLength)((0, _util.u8aConcat)(this.registry.createType('ContractSelector', selector).toU8a(), ...args.map((_ref6, index) => {
          let {
            type: {
              lookupName,
              type
            }
          } = _ref6;
          return this.registry.createType(lookupName || type, data[index]).toU8a();
        })));
      }
    });
    [this.json, this.registry, this.metadata, this.info] = parseJson((0, _util.isString)(abiJson) ? JSON.parse(abiJson) : abiJson, chainProperties);
    this.constructors = this.metadata.spec.constructors.map((spec, index) => (0, _classPrivateFieldLooseBase2.default)(this, _createMessage)[_createMessage](spec, index, {
      isConstructor: true
    }));
    this.events = this.metadata.spec.events.map((spec, index) => (0, _classPrivateFieldLooseBase2.default)(this, _createEvent)[_createEvent](spec, index));
    this.messages = this.metadata.spec.messages.map((spec, index) => {
      const typeSpec = spec.returnType.unwrapOr(null);
      return (0, _classPrivateFieldLooseBase2.default)(this, _createMessage)[_createMessage](spec, index, {
        isMutating: spec.mutates.isTrue,
        isPayable: spec.payable.isTrue,
        returnType: typeSpec ? this.registry.lookup.getTypeDef(typeSpec.type) : null
      });
    });
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeEvent(data) {
    const index = data[0];
    const event = this.events[index];
    (0, _util.assert)(event, () => `Unable to find event with index ${index}`);
    return event.fromU8a(data.subarray(1));
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeConstructor(data) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _decodeMessage)[_decodeMessage]('message', this.constructors, data);
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeMessage(data) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _decodeMessage)[_decodeMessage]('message', this.messages, data);
  }

  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }

  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }

}

exports.Abi = Abi;