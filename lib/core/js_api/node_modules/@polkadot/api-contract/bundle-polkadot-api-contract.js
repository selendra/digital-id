const polkadotApiContract = (function (exports, types, util, api, utilCrypto) {
  'use strict';

  const global = window;

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  var id = 0;
  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  function toLatest(registry, v0) {
    return registry.createType('ContractMetadataLatest', { ...v0,
      types: types.convertSiV0toV1(registry, v0.types)
    });
  }

  const l$1 = util.logger('Abi');
  const PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

  function findMessage(list, messageOrId) {
    const message = util.isNumber(messageOrId) ? list[messageOrId] : util.isString(messageOrId) ? list.find(({
      identifier
    }) => [identifier, util.stringCamelCase(identifier)].includes(messageOrId.toString())) : messageOrId;
    return util.assertReturn(message, () => `Attempted to call an invalid contract interface, ${util.stringify(messageOrId)}`);
  }

  function parseJson(json, chainProperties) {
    const registry = new types.TypeRegistry();
    const info = registry.createType('ContractProjectInfo', json);
    const metadata = registry.createType('ContractMetadata', util.isString(json.metadataVersion) ? {
      V0: json
    } : {
      V1: json.V1
    });
    const latest = metadata.isV0 ? toLatest(registry, metadata.asV0) : metadata.asV1;
    const lookup = registry.createType('PortableRegistry', {
      types: latest.types
    }); // attach the lookup to the registry - now the types are known

    registry.setLookup(lookup);

    if (chainProperties) {
      registry.setChainProperties(chainProperties);
    } // warm-up the actual type, pre-use


    lookup.types.forEach(({
      id
    }) => lookup.getTypeDef(id));
    return [json, registry, latest, info];
  }

  var _createArgs = /*#__PURE__*/_classPrivateFieldKey("createArgs");

  var _createEvent = /*#__PURE__*/_classPrivateFieldKey("createEvent");

  var _createMessage = /*#__PURE__*/_classPrivateFieldKey("createMessage");

  var _decodeArgs = /*#__PURE__*/_classPrivateFieldKey("decodeArgs");

  var _decodeMessage = /*#__PURE__*/_classPrivateFieldKey("decodeMessage");

  var _encodeArgs = /*#__PURE__*/_classPrivateFieldKey("encodeArgs");

  class Abi {
    constructor(abiJson, chainProperties) {
      this.events = void 0;
      this.constructors = void 0;
      this.info = void 0;
      this.json = void 0;
      this.messages = void 0;
      this.metadata = void 0;
      this.registry = void 0;
      Object.defineProperty(this, _createArgs, {
        writable: true,
        value: (args, spec) => {
          return args.map(({
            name,
            type
          }, index) => {
            try {
              util.assert(util.isObject(type), 'Invalid type definition found');
              const displayName = type.displayName.length ? type.displayName[type.displayName.length - 1].toString() : undefined;
              const camelName = util.stringCamelCase(name);

              if (displayName && PRIMITIVE_ALWAYS.includes(displayName)) {
                return {
                  name: camelName,
                  type: {
                    info: types.TypeDefInfo.Plain,
                    type: displayName
                  }
                };
              }

              const typeDef = this.registry.lookup.getTypeDef(type.type);
              return {
                name: camelName,
                type: displayName && !typeDef.type.startsWith(displayName) ? {
                  displayName,
                  ...typeDef
                } : typeDef
              };
            } catch (error) {
              l$1.error(`Error expanding argument ${index} in ${util.stringify(spec)}`);
              throw error;
            }
          });
        }
      });
      Object.defineProperty(this, _createEvent, {
        writable: true,
        value: (spec, index) => {
          const args = _classPrivateFieldBase(this, _createArgs)[_createArgs](spec.args, spec);

          const event = {
            args,
            docs: spec.docs.map(d => d.toString()),
            fromU8a: data => ({
              args: _classPrivateFieldBase(this, _decodeArgs)[_decodeArgs](args, data),
              event
            }),
            identifier: spec.name.toString(),
            index
          };
          return event;
        }
      });
      Object.defineProperty(this, _createMessage, {
        writable: true,
        value: (spec, index, add = {}) => {
          const args = _classPrivateFieldBase(this, _createArgs)[_createArgs](spec.args, spec);

          const identifier = spec.name.toString();
          const message = { ...add,
            args,
            docs: spec.docs.map(d => d.toString()),
            fromU8a: data => ({
              args: _classPrivateFieldBase(this, _decodeArgs)[_decodeArgs](args, data),
              message
            }),
            identifier,
            index,
            method: util.stringCamelCase(identifier),
            selector: spec.selector,
            toU8a: params => _classPrivateFieldBase(this, _encodeArgs)[_encodeArgs](spec, args, params)
          };
          return message;
        }
      });
      Object.defineProperty(this, _decodeArgs, {
        writable: true,
        value: (args, data) => {
          // for decoding we expect the input to be just the arg data, no selectors
          // no length added (this allows use with events as well)
          let offset = 0;
          return args.map(({
            type: {
              lookupName,
              type
            }
          }) => {
            const value = this.registry.createType(lookupName || type, data.subarray(offset));
            offset += value.encodedLength;
            return value;
          });
        }
      });
      Object.defineProperty(this, _decodeMessage, {
        writable: true,
        value: (type, list, data) => {
          const [, trimmed] = util.compactStripLength(data);
          const selector = trimmed.subarray(0, 4);
          const message = list.find(m => m.selector.eq(selector));
          util.assert(message, `Unable to find ${type} with selector ${util.u8aToHex(selector)}`);
          return message.fromU8a(trimmed.subarray(4));
        }
      });
      Object.defineProperty(this, _encodeArgs, {
        writable: true,
        value: ({
          name,
          selector
        }, args, data) => {
          util.assert(data.length === args.length, () => `Expected ${args.length} arguments to contract message '${name.toString()}', found ${data.length}`);
          return util.compactAddLength(util.u8aConcat(this.registry.createType('ContractSelector', selector).toU8a(), ...args.map(({
            type: {
              lookupName,
              type
            }
          }, index) => this.registry.createType(lookupName || type, data[index]).toU8a())));
        }
      });
      [this.json, this.registry, this.metadata, this.info] = parseJson(util.isString(abiJson) ? JSON.parse(abiJson) : abiJson, chainProperties);
      this.constructors = this.metadata.spec.constructors.map((spec, index) => _classPrivateFieldBase(this, _createMessage)[_createMessage](spec, index, {
        isConstructor: true
      }));
      this.events = this.metadata.spec.events.map((spec, index) => _classPrivateFieldBase(this, _createEvent)[_createEvent](spec, index));
      this.messages = this.metadata.spec.messages.map((spec, index) => {
        const typeSpec = spec.returnType.unwrapOr(null);
        return _classPrivateFieldBase(this, _createMessage)[_createMessage](spec, index, {
          isMutating: spec.mutates.isTrue,
          isPayable: spec.payable.isTrue,
          returnType: typeSpec ? this.registry.lookup.getTypeDef(typeSpec.type) : null
        });
      });
    }
    /**
     * Warning: Unstable API, bound to change
     */


    decodeEvent(data) {
      const index = data[0];
      const event = this.events[index];
      util.assert(event, () => `Unable to find event with index ${index}`);
      return event.fromU8a(data.subarray(1));
    }
    /**
     * Warning: Unstable API, bound to change
     */


    decodeConstructor(data) {
      return _classPrivateFieldBase(this, _decodeMessage)[_decodeMessage]('message', this.constructors, data);
    }
    /**
     * Warning: Unstable API, bound to change
     */


    decodeMessage(data) {
      return _classPrivateFieldBase(this, _decodeMessage)[_decodeMessage]('message', this.messages, data);
    }

    findConstructor(constructorOrId) {
      return findMessage(this.constructors, constructorOrId);
    }

    findMessage(messageOrId) {
      return findMessage(this.messages, messageOrId);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // Auto-generated by @polkadot/dev, do not edit
  const packageInfo = {
    name: '@polkadot/api-contract',
    version: '6.8.1'
  };

  // Copyright 2017-2021 @polkadot/rpc-contract authors & contributors
  function applyOnEvent(result, types, fn) {
    if (result.isInBlock || result.isFinalized) {
      const records = result.filterRecords('contracts', types);

      if (records.length) {
        return fn(records);
      }
    }

    return undefined;
  }
  function isOptions(options) {
    return !(util.isBn(options) || util.isBigInt(options) || util.isNumber(options) || util.isString(options));
  }
  function extractOptions(value, params) {
    const gasLimit = params.shift();
    return [{
      gasLimit,
      value
    }, params];
  }

  // Copyright 2017-2021 @polkadot/api authors & contributors
  class Base {
    constructor(api, abi, decorateMethod) {
      this.abi = void 0;
      this.api = void 0;
      this._decorateMethod = void 0;
      this.abi = abi instanceof Abi ? abi : new Abi(abi, api.registry.getChainProperties());
      this.api = api;
      this._decorateMethod = decorateMethod;
      util.assert(!!(api && api.isConnected && api.tx), 'Your API has not been initialized correctly and is not connected to a chain');
      util.assert(!!(api.tx.contracts && Object.keys(api.tx.contracts).length), 'You need to connect to a chain with a runtime that supports contracts');
      util.assert(util.isFunction(api.tx.contracts.instantiateWithCode), 'You need to connect to a chain with a runtime with a V3 contracts module. The runtime does not expose api.tx.contracts.instantiateWithCode');
    }

    get registry() {
      return this.api.registry;
    }

  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
      return to;
  }

  function isFunction(value) {
      return typeof value === 'function';
  }

  function createErrorClass(createImpl) {
      var _super = function (instance) {
          Error.call(instance);
          instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
  }

  var UnsubscriptionError = createErrorClass(function (_super) {
      return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors
              ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
              : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
      };
  });

  function arrRemove(arr, item) {
      if (arr) {
          var index = arr.indexOf(item);
          0 <= index && arr.splice(index, 1);
      }
  }

  var Subscription = (function () {
      function Subscription(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._teardowns = null;
      }
      Subscription.prototype.unsubscribe = function () {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
              this.closed = true;
              var _parentage = this._parentage;
              if (_parentage) {
                  this._parentage = null;
                  if (Array.isArray(_parentage)) {
                      try {
                          for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                              var parent_1 = _parentage_1_1.value;
                              parent_1.remove(this);
                          }
                      }
                      catch (e_1_1) { e_1 = { error: e_1_1 }; }
                      finally {
                          try {
                              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                      }
                  }
                  else {
                      _parentage.remove(this);
                  }
              }
              var initialTeardown = this.initialTeardown;
              if (isFunction(initialTeardown)) {
                  try {
                      initialTeardown();
                  }
                  catch (e) {
                      errors = e instanceof UnsubscriptionError ? e.errors : [e];
                  }
              }
              var _teardowns = this._teardowns;
              if (_teardowns) {
                  this._teardowns = null;
                  try {
                      for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                          var teardown_1 = _teardowns_1_1.value;
                          try {
                              execTeardown(teardown_1);
                          }
                          catch (err) {
                              errors = errors !== null && errors !== void 0 ? errors : [];
                              if (err instanceof UnsubscriptionError) {
                                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                              }
                              else {
                                  errors.push(err);
                              }
                          }
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
              }
              if (errors) {
                  throw new UnsubscriptionError(errors);
              }
          }
      };
      Subscription.prototype.add = function (teardown) {
          var _a;
          if (teardown && teardown !== this) {
              if (this.closed) {
                  execTeardown(teardown);
              }
              else {
                  if (teardown instanceof Subscription) {
                      if (teardown.closed || teardown._hasParent(this)) {
                          return;
                      }
                      teardown._addParent(this);
                  }
                  (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
              }
          }
      };
      Subscription.prototype._hasParent = function (parent) {
          var _parentage = this._parentage;
          return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
      };
      Subscription.prototype._addParent = function (parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription.prototype._removeParent = function (parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
              this._parentage = null;
          }
          else if (Array.isArray(_parentage)) {
              arrRemove(_parentage, parent);
          }
      };
      Subscription.prototype.remove = function (teardown) {
          var _teardowns = this._teardowns;
          _teardowns && arrRemove(_teardowns, teardown);
          if (teardown instanceof Subscription) {
              teardown._removeParent(this);
          }
      };
      Subscription.EMPTY = (function () {
          var empty = new Subscription();
          empty.closed = true;
          return empty;
      })();
      return Subscription;
  }());
  function isSubscription(value) {
      return (value instanceof Subscription ||
          (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
  }
  function execTeardown(teardown) {
      if (isFunction(teardown)) {
          teardown();
      }
      else {
          teardown.unsubscribe();
      }
  }

  var config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: undefined,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false,
  };

  var timeoutProvider = {
      setTimeout: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
      },
      clearTimeout: function (handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: undefined,
  };

  function reportUnhandledError(err) {
      timeoutProvider.setTimeout(function () {
          {
              throw err;
          }
      });
  }

  function noop() { }

  var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
  function errorNotification(error) {
      return createNotification('E', undefined, error);
  }
  function nextNotification(value) {
      return createNotification('N', value, undefined);
  }
  function createNotification(kind, value, error) {
      return {
          kind: kind,
          value: value,
          error: error,
      };
  }

  var context = null;
  function captureError(err) {
      if (config.useDeprecatedSynchronousErrorHandling && context) {
          context.errorThrown = true;
          context.error = err;
      }
  }

  var Subscriber = (function (_super) {
      __extends(Subscriber, _super);
      function Subscriber(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
              _this.destination = destination;
              if (isSubscription(destination)) {
                  destination.add(_this);
              }
          }
          else {
              _this.destination = EMPTY_OBSERVER;
          }
          return _this;
      }
      Subscriber.create = function (next, error, complete) {
          return new SafeSubscriber(next, error, complete);
      };
      Subscriber.prototype.next = function (value) {
          if (this.isStopped) {
              handleStoppedNotification(nextNotification(value), this);
          }
          else {
              this._next(value);
          }
      };
      Subscriber.prototype.error = function (err) {
          if (this.isStopped) {
              handleStoppedNotification(errorNotification(err), this);
          }
          else {
              this.isStopped = true;
              this._error(err);
          }
      };
      Subscriber.prototype.complete = function () {
          if (this.isStopped) {
              handleStoppedNotification(COMPLETE_NOTIFICATION, this);
          }
          else {
              this.isStopped = true;
              this._complete();
          }
      };
      Subscriber.prototype.unsubscribe = function () {
          if (!this.closed) {
              this.isStopped = true;
              _super.prototype.unsubscribe.call(this);
              this.destination = null;
          }
      };
      Subscriber.prototype._next = function (value) {
          this.destination.next(value);
      };
      Subscriber.prototype._error = function (err) {
          try {
              this.destination.error(err);
          }
          finally {
              this.unsubscribe();
          }
      };
      Subscriber.prototype._complete = function () {
          try {
              this.destination.complete();
          }
          finally {
              this.unsubscribe();
          }
      };
      return Subscriber;
  }(Subscription));
  var SafeSubscriber = (function (_super) {
      __extends(SafeSubscriber, _super);
      function SafeSubscriber(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var next;
          if (isFunction(observerOrNext)) {
              next = observerOrNext;
          }
          else if (observerOrNext) {
              (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
              var context_1;
              if (_this && config.useDeprecatedNextContext) {
                  context_1 = Object.create(observerOrNext);
                  context_1.unsubscribe = function () { return _this.unsubscribe(); };
              }
              else {
                  context_1 = observerOrNext;
              }
              next = next === null || next === void 0 ? void 0 : next.bind(context_1);
              error = error === null || error === void 0 ? void 0 : error.bind(context_1);
              complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
          }
          _this.destination = {
              next: next ? wrapForErrorHandling(next) : noop,
              error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
              complete: complete ? wrapForErrorHandling(complete) : noop,
          };
          return _this;
      }
      return SafeSubscriber;
  }(Subscriber));
  function wrapForErrorHandling(handler, instance) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          try {
              handler.apply(void 0, __spreadArray([], __read(args)));
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  captureError(err);
              }
              else {
                  reportUnhandledError(err);
              }
          }
      };
  }
  function defaultErrorHandler(err) {
      throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config.onStoppedNotification;
      onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
  }
  var EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop,
  };

  function hasLift(source) {
      return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
      return function (source) {
          if (hasLift(source)) {
              return source.lift(function (liftedSource) {
                  try {
                      return init(liftedSource, this);
                  }
                  catch (err) {
                      this.error(err);
                  }
              });
          }
          throw new TypeError('Unable to lift unknown Observable type');
      };
  }

  var OperatorSubscriber = (function (_super) {
      __extends(OperatorSubscriber, _super);
      function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this._next = onNext
              ? function (value) {
                  try {
                      onNext(value);
                  }
                  catch (err) {
                      destination.error(err);
                  }
              }
              : _super.prototype._next;
          _this._error = onError
              ? function (err) {
                  try {
                      onError(err);
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._error;
          _this._complete = onComplete
              ? function () {
                  try {
                      onComplete();
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._complete;
          return _this;
      }
      OperatorSubscriber.prototype.unsubscribe = function () {
          var _a;
          var closed = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      };
      return OperatorSubscriber;
  }(Subscriber));

  function map(project, thisArg) {
      return operate(function (source, subscriber) {
          var index = 0;
          source.subscribe(new OperatorSubscriber(subscriber, function (value) {
              subscriber.next(project.call(thisArg, value, index++));
          }));
      });
  }

  const MAX_CALL_GAS = new util.BN(5000000000000).isub(util.BN_ONE);
  const ERROR_NO_CALL = 'Your node does not expose the contracts.call RPC. This is most probably due to a runtime configuration.';
  const l = util.logger('Contract');

  function createQuery(fn) {
    return (origin, options, ...params) => isOptions(options) ? fn(origin, options, params) : fn(origin, ...extractOptions(options, params));
  }

  function createTx(fn) {
    return (options, ...params) => isOptions(options) ? fn(options, params) : fn(...extractOptions(options, params));
  }

  class ContractSubmittableResult extends api.SubmittableResult {
    constructor(result, contractEvents) {
      super(result);
      this.contractEvents = void 0;
      this.contractEvents = contractEvents;
    }

  }

  var _query = /*#__PURE__*/_classPrivateFieldKey("query");

  var _tx$2 = /*#__PURE__*/_classPrivateFieldKey("tx");

  var _getGas = /*#__PURE__*/_classPrivateFieldKey("getGas");

  var _exec = /*#__PURE__*/_classPrivateFieldKey("exec");

  var _read = /*#__PURE__*/_classPrivateFieldKey("read");

  class Contract$2 extends Base {
    /**
     * @description The on-chain address for this contract
     */
    constructor(api, abi, address, decorateMethod) {
      super(api, abi, decorateMethod);
      this.address = void 0;
      Object.defineProperty(this, _query, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _tx$2, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _getGas, {
        writable: true,
        value: (_gasLimit, isCall = false) => {
          const gasLimit = util.bnToBn(_gasLimit);
          return gasLimit.lte(util.BN_ZERO) ? isCall ? MAX_CALL_GAS : (this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system.maximumBlockWeight).muln(64).div(util.BN_HUNDRED) : gasLimit;
        }
      });
      Object.defineProperty(this, _exec, {
        writable: true,
        value: (messageOrId, {
          gasLimit = util.BN_ZERO,
          value = util.BN_ZERO
        }, params) => {
          return this.api.tx.contracts.call(this.address, value, _classPrivateFieldBase(this, _getGas)[_getGas](gasLimit), this.abi.findMessage(messageOrId).toU8a(params)).withResultTransform(result => // ContractEmitted is the current generation, ContractExecution is the previous generation
          new ContractSubmittableResult(result, applyOnEvent(result, ['ContractEmitted', 'ContractExecution'], records => records.map(({
            event: {
              data: [, data]
            }
          }) => {
            try {
              return this.abi.decodeEvent(data);
            } catch (error) {
              l.error(`Unable to decode contract event: ${error.message}`);
              return null;
            }
          }).filter(decoded => !!decoded))));
        }
      });
      Object.defineProperty(this, _read, {
        writable: true,
        value: (messageOrId, {
          gasLimit = util.BN_ZERO,
          value = util.BN_ZERO
        }, params) => {
          util.assert(this.hasRpcContractsCall, ERROR_NO_CALL);
          const message = this.abi.findMessage(messageOrId);
          return {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            send: this._decorateMethod(origin => this.api.rx.rpc.contracts.call({
              dest: this.address,
              gasLimit: _classPrivateFieldBase(this, _getGas)[_getGas](gasLimit, true),
              inputData: message.toU8a(params),
              origin,
              value
            }).pipe(map(({
              debugMessage,
              gasConsumed,
              gasRequired,
              result
            }) => ({
              debugMessage,
              gasConsumed,
              gasRequired: gasRequired && !gasRequired.isZero() ? gasRequired : gasConsumed,
              output: result.isOk && message.returnType ? this.abi.registry.createTypeUnsafe(message.returnType.lookupName || message.returnType.type, [result.asOk.data.toU8a(true)], {
                isPedantic: true
              }) : null,
              result
            }))))
          };
        }
      });
      this.address = this.registry.createType('AccountId', address);
      this.abi.messages.forEach(m => {
        if (util.isUndefined(_classPrivateFieldBase(this, _tx$2)[_tx$2][m.method])) {
          _classPrivateFieldBase(this, _tx$2)[_tx$2][m.method] = createTx((o, p) => _classPrivateFieldBase(this, _exec)[_exec](m, o, p));
        }

        if (util.isUndefined(_classPrivateFieldBase(this, _query)[_query][m.method])) {
          _classPrivateFieldBase(this, _query)[_query][m.method] = createQuery((f, o, p) => _classPrivateFieldBase(this, _read)[_read](m, o, p).send(f));
        }
      });
    }

    get hasRpcContractsCall() {
      var _this$api$rx$rpc$cont;

      return util.isFunction((_this$api$rx$rpc$cont = this.api.rx.rpc.contracts) === null || _this$api$rx$rpc$cont === void 0 ? void 0 : _this$api$rx$rpc$cont.call);
    }

    get query() {
      util.assert(this.hasRpcContractsCall, ERROR_NO_CALL);
      return _classPrivateFieldBase(this, _query)[_query];
    }

    get tx() {
      return _classPrivateFieldBase(this, _tx$2)[_tx$2];
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  const EMPTY_SALT = new Uint8Array();
  function createBluePrintTx(fn) {
    return (options, ...params) => isOptions(options) ? fn(options, params) : fn(...extractOptions(options, params));
  }
  function encodeSalt(salt = utilCrypto.randomAsU8a()) {
    return salt instanceof types.Bytes ? salt : salt && salt.length ? util.compactAddLength(util.u8aToU8a(salt)) : EMPTY_SALT;
  }

  class BlueprintSubmittableResult extends api.SubmittableResult {
    constructor(result, contract) {
      super(result);
      this.contract = void 0;
      this.contract = contract;
    }

  }

  var _tx$1 = /*#__PURE__*/_classPrivateFieldKey("tx");

  var _deploy = /*#__PURE__*/_classPrivateFieldKey("deploy");

  class Blueprint$2 extends Base {
    /**
     * @description The on-chain code hash for this blueprint
     */
    constructor(api, abi, codeHash, decorateMethod) {
      super(api, abi, decorateMethod);
      this.codeHash = void 0;
      Object.defineProperty(this, _tx$1, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _deploy, {
        writable: true,
        value: (constructorOrId, {
          gasLimit = util.BN_ZERO,
          salt,
          value = util.BN_ZERO
        }, params) => {
          return this.api.tx.contracts.instantiate(value, gasLimit, this.codeHash, this.abi.findConstructor(constructorOrId).toU8a(params), encodeSalt(salt)).withResultTransform(result => new BlueprintSubmittableResult(result, applyOnEvent(result, ['Instantiated'], ([record]) => new Contract$2(this.api, this.abi, record.event.data[1], this._decorateMethod))));
        }
      });
      this.codeHash = this.registry.createType('Hash', codeHash);
      this.abi.constructors.forEach(c => {
        if (util.isUndefined(_classPrivateFieldBase(this, _tx$1)[_tx$1][c.method])) {
          _classPrivateFieldBase(this, _tx$1)[_tx$1][c.method] = createBluePrintTx((o, p) => _classPrivateFieldBase(this, _deploy)[_deploy](c, o, p));
        }
      });
    }

    get tx() {
      return _classPrivateFieldBase(this, _tx$1)[_tx$1];
    }

  }

  class CodeSubmittableResult extends api.SubmittableResult {
    constructor(result, blueprint, contract) {
      super(result);
      this.blueprint = void 0;
      this.contract = void 0;
      this.blueprint = blueprint;
      this.contract = contract;
    }

  }

  var _tx = /*#__PURE__*/_classPrivateFieldKey("tx");

  var _instantiate = /*#__PURE__*/_classPrivateFieldKey("instantiate");

  class Code$2 extends Base {
    constructor(api, abi, wasm, decorateMethod) {
      super(api, abi, decorateMethod);
      this.code = void 0;
      Object.defineProperty(this, _tx, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _instantiate, {
        writable: true,
        value: (constructorOrId, {
          gasLimit = util.BN_ZERO,
          salt,
          value = util.BN_ZERO
        }, params) => {
          return this.api.tx.contracts.instantiateWithCode(value, gasLimit, util.compactAddLength(this.code), this.abi.findConstructor(constructorOrId).toU8a(params), encodeSalt(salt)).withResultTransform(result => new CodeSubmittableResult(result, ...(applyOnEvent(result, ['CodeStored', 'Instantiated'], records => records.reduce(([blueprint, contract], {
            event
          }) => this.api.events.contracts.Instantiated.is(event) ? [blueprint, new Contract$2(this.api, this.abi, event.data[1], this._decorateMethod)] : this.api.events.contracts.CodeStored.is(event) ? [new Blueprint$2(this.api, this.abi, event.data[0], this._decorateMethod), contract] : [blueprint, contract], [])) || [])));
        }
      });
      this.code = util.isWasm(this.abi.info.source.wasm) ? this.abi.info.source.wasm : util.u8aToU8a(wasm);
      util.assert(util.isWasm(this.code), 'No WASM code provided');
      this.abi.constructors.forEach(c => {
        if (util.isUndefined(_classPrivateFieldBase(this, _tx)[_tx][c.method])) {
          _classPrivateFieldBase(this, _tx)[_tx][c.method] = createBluePrintTx((o, p) => _classPrivateFieldBase(this, _instantiate)[_instantiate](c, o, p));
        }
      });
    }

    get tx() {
      return _classPrivateFieldBase(this, _tx)[_tx];
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Blueprint$1 extends Blueprint$2 {
    constructor(api$1, abi, codeHash) {
      super(api$1, abi, codeHash, api.toPromiseMethod);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Code$1 extends Code$2 {
    constructor(api$1, abi, wasm) {
      super(api$1, abi, wasm, api.toPromiseMethod);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Contract$1 extends Contract$2 {
    constructor(api$1, abi, address) {
      super(api$1, abi, address, api.toPromiseMethod);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Blueprint extends Blueprint$2 {
    constructor(api$1, abi, codeHash) {
      super(api$1, abi, codeHash, api.toRxMethod);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Code extends Code$2 {
    constructor(api$1, abi, wasm) {
      super(api$1, abi, wasm, api.toRxMethod);
    }

  }

  // Copyright 2017-2021 @polkadot/api-contract authors & contributors
  class Contract extends Contract$2 {
    constructor(api$1, abi, address) {
      super(api$1, abi, address, api.toRxMethod);
    }

  }

  exports.Abi = Abi;
  exports.BlueprintPromise = Blueprint$1;
  exports.BlueprintRx = Blueprint;
  exports.CodePromise = Code$1;
  exports.CodeRx = Code;
  exports.ContractPromise = Contract$1;
  exports.ContractRx = Contract;
  exports.packageInfo = packageInfo;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, polkadotTypes, polkadotUtil, polkadotApi, polkadotUtilCrypto);
